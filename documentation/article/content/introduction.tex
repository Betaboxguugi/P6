\section{Introduction}\label{intro} % The \section*{} command stops section numbering
%\addcontentsline{toc}{section}{Introduction} % Adds this section to the table of contents
To ensure that a piece of software can be expected to run at low risk of failure, it must be tested. Today we have specialized software that assist in the automatic execution of tests. This allows testers to focus more on what to test and less on test implementation. This leads to tests of a higher quality.

Some testing tools have a broad application, while other test tools have a more specific use. Per extension, there exists many tools exclusively used for testing \textit{Extract-Transform-Load} (ETL) systems. These systems support the creation and update of \textit{data warehouses} (DW), which are mainly used for business analysis. An ETL process will extract data from a set of sources, apply transformations to that data and load it into a DW. Often GUI-based tools are used, when developing ETL systems. The pygrametl python package, which is open source, allows coding of entire ETL systems instead. The main idea being that experts perform better when using an API rather than a GUI \cite{thomsen2009pygrametl}. Our goal is to develop a testing framework, which can assist users of pygrametl in testing their ETL systems.

ETL tests may be set up manually using SQL. Yet, in the current market many different testing tools exists. These allow for the automation of tests. Testing often occurs by focusing on the DW, which the ETL system populates. QuerySurge\cite{QuerySurge} for example, focuses on comparing the data from sources to the data in the DW. The tool is built on the idea that data is often unaltered, as it passes through the ETL process. This means that column A in a source must be one-to-one mappable to column B in the DW. Testing of this type only requires the user to supply some simple mappings between sources and DW. As such, QuerySurge presents itself as a novice-friendly solution and allows for testing through a GUI. Yet, if mappings between source data and DW become more complex, testers will need to write SQL code to test. We determine that this kind of tool is not fitting for the users of pygrametl. As pygrametl users are expert users, who will not gain anything from the novice-friendly features of QuerySurge. The amount of code needed for testing may also be rather large, if there is a frequent need for SQL.

Testing may also occur through the comparison of tables within a populated DW with those defined by the tester. By constructing a table, testers assert how a DW table should look after load. The truth of this assertion can be found by comparing to the actual DW table. For this, tools such as AnyDBTest\cite{AnyDbTest} may be used. AnyDBTest also allows testers to describe, what kind of comparison should be made. For example, we may assert that one table is the subset of another. The problem with this type of testing, is that it requires the setup of many user-defined tables. Again, a large amount of test code needs to be written. However, we do believe that table comparison is a powerful tool for ETL testing. Yet, comparison between tables should not be the only assertable property of a DW.

Having looked at some of the currently available tools, we find that they require a lot of test code to be written. To get a wider test coverage, we need to decrease the amount of code necessary for each test. We also worry that faults may be more prevalent to occur in the test code, as it grows larger. Such faults can undermine the usefulness and accuracy of test results.

To allow for automated testing of pygrametl programs, we develop \textit{\FW{}}. Our motivation for developing \FW{} is that no other testing tool has been made with pygrametl in mind. As of writing, testers will have to test manually or use third-party tools that are either rather broad in application or that require the use of a GUI. With \FW{}, we aim to help testers in writing less code for a single test. This will lead to less time spent on each test, enabling a wider test coverage. Covering more of the software will increase its overall quality. We also need the tests to be executed at a reasonable speed. If the tests are quick to write, but slow to execute, users may use other methods However, we deem this less important to how long it takes to write the tests.

The rest of this paper is organized as follows. \Cref{sect:RelatedWork} will give a brief overview of some related work. This is followed by an introduction to the pygrametl python package in \Cref{sect:pygrametl}. \Cref{sect:btesting} will explain some basic testing terminology relevant to the paper. This leads into an overview of \FW{} in \Cref{sect:Overview}. \Cref{sec:dwpopulator} shows how the framework performs setup before testing. In \Cref{sect:interdatarep} we describe the classes used to represent the DW during testing. Afterwards, \Cref{sect:pred} explains the different types of predicates, used to assert properties of a DW. \Cref{sect:eval} will focus on evaluating the framework. Finally, in \Cref{sect:conc} we conclude upon the paper.





 



