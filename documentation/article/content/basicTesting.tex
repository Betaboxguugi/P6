\section{The Basics of Software Testing}\label{sect:btesting}
This section introduces some of the basics of software testing. These will assist in understanding the work documented in later sections. The definitions used in this section are taken from the books \textit{Guide to Advanced Software Testing} by Anne Mette Jonassen Hass\cite{Hass} and \textit{Software Testing Techniques} by Boris Beizer\cite{Beizer}.

Testing is an integral part of the software development process at large. It is included in many different software process models. But, what is testing exactly? Hass defines it as follows: 
 \begin{quotation} \textit{Testing gathers information about the quality of the object under test.}\end{quotation}  
Knowing the quality of a piece of software allows an organization to evaluate, whether it is fit for purpose. If not, test results may guide an effort to increase quality.

Before tests can be executed they must be designed.  Design can be done from two different points of view: Functional and Structural. With functional, software is treated like a black box receiving input and computing output. Tests are designed to verify, whether the software conforms to specified behaviour. Structural involves designing test based on the internal structure of the software. Here a tester could for instance test how a piece of code logically branches during execution. The structural approach is often used, when testing individual components. Functional is more apt to use, when testing a set of integrated units or an entire system. 

As with any other process, testing is restricted by both time and resources available. These greatly affect the quality of testing performed, often called test coverage. Because of this, testers are almost never able to perform exhaustive testing, where all combinations of input and preconditions are tested. Instead, testers select the most important areas to focus on during testing.  

Tools are often used to assist in the testing process. An example is the testing framework, which assist in the automatic execution of tests. By the push of a button, a framework can execute a set of user-defined test cases, setting up and tearing down objects as needed. A test case is a well defined set of preconditions and input given to a component. This is  accompanied by a set of expected output and postconditions. A test case passes or fails, depending whether actual output and postconditions match expectations.  The required test coverage is often acquired by designing a set of test cases. An advantage of frameworks is that testers can spend more time on test design. Less time will have to be spend on how to implement tests. In theory this leads to testing of a higher quality.

Another bonus of using a framework is that it allows for regression testing. This becomes mostly relevant in the maintenance part of the software life cycle. During this time, new features may be added and bugs fixed. Testers want to ensure that such changes do not lead to regression,  where software quality deteriorates. With a framework, regression testing is simple. Once a set of test cases have been set up, they can be run after a change has been made. This will then gauge whether regression has occurred.


