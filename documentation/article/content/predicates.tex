\section{Predicates}
\todo[inline]{Skriv introduktion.}
In the following section...

\subsection{ColumnNotNullPredicate}
ColumnNotNullPredicate asserts that a all entries of each row in a specified list of columns within a table, does not contain null. Allowing a user to insure that the data within a table has all entries filled after a use of a function or insertion of data.
The ColumnNotNullPredicate is instantiated as follows, with description of the parameters below.

\insertcodefile{codeRelated/Scripts/ColumnNotNullPredicate.py}{Instantiation of ColumnNotNullPredicate}

\insertcode{CompareTablePredicate(actual_name='table1',
                      expected_table=[{'attr1':1}],
                      ignore_atts=['attr0', 'attr2'],
                      subset=True)
}{LOL}

\begin{description}
\item [table\_name] a string containing the name of the specific table from a data warehouse, that the test must run on. 
\item [column\_names] a list of strings or a string containing the name(s) of the column(s), which specifies which column(s) the predicate should test within the table
\end{description}

ColumnNotNullPredicate iterates over every row in the specified table. In each row it then iterates over each element in the column(s) specified. Through this later iteration it insures that each element is not null. If null is found, the row it was found in is appended to a list, which is displayed as part of the report object, which also will report the result of the test, as false.

\subsection{CompareTablePredicate}
CompareTablePredicate asserts that two tables are either equal or that one is a subset of the other. It is made to allow users to give an expected table to compare with the actual one populated by their pygrametl program. It checks if an identical row exists in the actual table, for each row in the expected table. The CompareTablePredicate is instantiated as follows, with description of the parameters below.

\begin{lstlisting}[basicstyle=\scriptsize, language=Python]
CompareTablePredicate(actual_name='table1',
                      expected_table=[{'attr1':1}],
                      ignore_atts=['attr0', 'attr2'],
                      subset=True)
\end{lstlisting}

\begin{description}
\item [actual\_name] is a string containing the name of the table from your datawarehouse, you would like to compare with the given \textit{expected\_table}. It is used to index our datawarehouse representation and then retrieve the actual table.
\item [expected\_table] is a list of dictionaries, representing a database table, and is used to check whether it is equal to, or a subset of the actual table.
\item [ignore\_atts] is a list of string containing the names of the attributes you wish to ignore when comparing the two tables. E.g. one could imagine that it would be nice to not compare on surrogate keys, as they might change from run to run of the pygrametl program.
  \item [subset] is a boolean, if \textit{true} the expected table only has to be a subset of the actual table, else they have to be equal.
\end{description}

CompareTablePredicate works by using the filterfalse function from the standard python package \textit{itertools}. It uses this to take the relative complement of the two tables and we assert that the predicate holds true for the case of \textit{subset} equal \textit{true} if,

\[ A \backslash E \equiv \emptyset \]

\noindent which implies that $A \subseteq E$, where A is the actual table and E is the expected table.

And for \textit{subset} equal \textit{false} if,

\[ A \backslash E \cup E \backslash A \equiv \emptyset \]

\noindent which implies that $A \equiv E$, where A is the actual table and E is the expected table.

\subsection{RuleColumnPredicate}

RuleColumnPredicate asserts that a all entries of each row in a specified list of columns within a table, complies with a constraint, given trough a predicate made by the user. This allows the user a lot of freedom in their tests, as they can test each row of elements in a given table, in any way they wish. Insuring the data complies with the requirements they have set for it. The RuleColumnPredicate is instantiated as follows, with description of the parameters below.

\begin{lstlisting}[basicstyle=\scriptsize, language=Python]
def constraint1(a,b):
	if a > 20000 and b < 80:
		return true
	else:
		return false

RuleColumnPredicate(table_name='company',
                    constraint_function=constraint1,
                    column_names=['sales', 'age'],
                    return_list=None)
\end{lstlisting}

\begin{description}
\item [table\_name] a string containing the name of specific table from as data warehouse. 
\item [constraint\_function] a predicate that represent the constraint which need to be tested. When called it must return either true, if the constraint is fulfilled, or false if it's not.
\item [column\_names] a list of strings or a string containing the name(s) of the column(s), which specifies which column(s) the predicate should test within in the table
\item [return\_list] a bool, if false then all elements from the column(s) is send as arguments to the constraint function, if true they are send as a list instead.
\end{description}

RuleColumnPredicate iterates over every row in the specified table. For each row, it iterates over the column(s) specified, where it takes each element from each column(s) and calls the constraint function on those elements as either arguments or a list, depending on what the user has specified. If the constraint function returns false on a row, then the row is appended to a list, which is displayed as part of the report object, which also will report the result of the test, as false. RuleColumnPredicate does not support constraints with a variable number of arguments.


