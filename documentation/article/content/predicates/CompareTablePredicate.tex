\subsection{CompareTablePredicate}
CompareTablePredicate is by far the most verbose of the predicates, and it is used to assert that two tables uphold some type of comparison. The predicate allows testers to compare an actual table, or join of tables, within the DW to one expected by the user. Users have different options, in how they would like to compare two tables. They may want to check for a one to one equality between tables, or whether the contents of one table is included in another. In some cases, testers also want their comparisons to treat tables as sets, while at other times duplicates should be accounted for in the comparison. The CompareTablePredicate is instantiated as follows, with description of the parameters below.

\insertcodefile{CompareTablePredicate.py}{Instantiation of CompareTablePredicate}

\begin{description}
\item [actual\_table] is a string containing the name of the table from the DW to be compared with \textit{expected\_table}. May be given as a list of strings, if a natural join of tables is needed for comparison.
\item [expected\_table] is the user given table to compare against. If the table resides in the DW, then it may be given by a string containing its name. If the tester wants a natural join of tables, then a list of strings may be given. Instead of strings, the parameter may also be given a cursor, from which data can be fetched, or a list of dictionaries.
\item [sort] a bool to indicate, whether a sort compare should be used.
\item [sort\_keys] a set of attribute names to sort the tables upon, when doing a sort compare.
\item [distinct] a bool to indicate, whether the tables should be treated as distinct, or if duplicates should be accounted for during comparison.
\item [subset] a bool to indicate, if the comparison should only check, whether the contents of the expected table is contained within the actual table. Or whether the comparison should go both ways. 
\end{description}

For the instantiation above, we assert that BookDim contains the 2nd version of the Hobbit. We ignore the bid attribute for the compare, as it is a surrogate key. We do not perform sort compare. We also indicate that the tables should not be viewed as distinct. This is important, as the row within expected should only appear once in actual. We want to make sure that no duplicates of it exists within the actual table. 

When running the predicate, it performs comparisons differently based on settings chosen, and how the expected table is stored. In general the fastest execution comes from having expected table contained within the DW. As such, testers may want to insert such test tables into the DW. If expected table is given as a list or dictionaries or a cursor, it will be slower as comparison cannot be made at the database level.  When a cursor is given, its contents are fetched and paired with attribute names to make a list of dictionaries. 

No matter how the expected table is given, sort comparison is performed in much the same way. Sort compare can only be done for a one to one comparison between tables, a subset version has not been implemented.

If a set of sort keys have not been given, the predicate tries to find one. This is done by constructing a union of all keys from the tables that make up the actual table. If a sub-table is a dimension, the key may be either its primary key or its set of lookup attributes. For a fact table, the key is the set of key references. The sort key can only be constructed, if keys of all sub-tables appear in the set of columns, which we compare upon. These are given by \textit{column\_names} and \textit{column\_names\_exclude}. This is a rather brute force way of generating a sort key. In some cases, sort can be performed successfully, where this method fails to find a key. In that case, the tester may themselves include a sort key. 

I we have access to a sort key, a sorted compare is performed. The tables within the DW are fetched and sorted through a query using the ORDER BY clause. If the expected table is a list of dictionaries, it is sorted using the built-in python function \textit{sorted}. After sort, we iterate over both the actual and expected table. At each iteration, we fetch the next row of both tables and perform a compare, logging any failed comparisons. This comparison occurs through python. When the rows are fetched into python it  converts all nulls to instances of the None type. This is problematic as Null = Null equals unknown and None = None equals True. To mimic to the SQL type of comparison, we log all rows containing Nones as faulty. This is done throughout the predicate, when performing comparisons outside SQL. After the comparison is over, we report whether the assertion held or not. As a single faulty row may impact the sort order, we do not report on the faulty rows as these may end up containing the entire table. 

In theory sorted compare should be the fastest comparison to perform in the predicate. This is because sorting in SQL usually takes O(n log(n))-time, and the actual comparison runs in O(n). Here n is the size of the largest of the two tables. As in the case of any SQL query however, runtime depends on many different factors such as the actual SQL implementation.

In the case where a sort compare is not possible, we use other methods. The methods used, do depend on whether the expected table is contained within the DW, or if it is a list of dictionaries. 

In the case that expected table resides in the DW and ww do not account for duplicates, we use the following SQL query:

\insertcodefileSQL{SQLCompareTableDW.sql}{SQL query if expected table was in DW  the case of \cref{CompareTablePredicate.py} and tables are treated as distinct}

This is equivalent to finding the difference between the actual table, BookDim, and the expected table. In the case that all rows of BookDim reside in Expected this should return an empty table. In set theory this is given by:

\[ E \backslash A \equiv \emptyset \]

This implies that $E \subseteq A$. In the case where we are not checking for subset, but one to one equality, we perform both the query above, and another where we check that  $A \subseteq $E. In set theory this is the same as saying:

\[ A \backslash E \cup E \backslash A \equiv \emptyset \]

Which implies that $A \equiv E$. In the case, where we have to take account of duplicates within the tables, we have to perform another query. This is shown in:

\insertcodefileSQL{SQLCompareTableDW.sql}{SQL query if expected table was in DW  the case of \cref{CompareTablePredicate.py} and tables are not treated as distinct} 

By grouping together similar rows within each table, we can do the comparison as before. The where clause is extended to also account for the new Count attribute, which indicates the amount of duplicates of a given row. For a one to one comparison, this query is simply performed both ways. In the case of checking for subset, we only perform the query checking whether expected is contained within actual. The where clause is also changed so that it does not check for equality, but less or equal to. This is because expected is still a subset of even if it has 2 instances of a row, while actual has 3. 

In the case where expected is a list of dicts,  the comparisons are much the same. Instead of SQL, we use python composite statements and the filterfalse method to find fault rows during comparison. This is much slower, than in the previous case as comparison is not done at the database level.