\subsection{NoDuplicateRowPredicate}

NoDuplicateRowPredicate asserts that a table does not have two or more rows which are a duplicate of each other. It can be specified to only look at certain columns, where it will consider the columns specified as the rows it looks upon. This can helpful in routing out problems when applying joins, as duplicates can occur in one or more columns when doing so. Otherwise it can also be used after creation of a table or insertion of data into one, as this is also a common area where duplicates may be found if something were done improperly.
 
\insertcodefile{NoDuplicateRowPredicate.py}{Instantiation of NoDuplicateRowPredicate}

NoDuplicateRowPredicate chooses a row from the specified table and checks whether it's unique from each of the remaining rows in the table, and does so for every row, except previously tested rows. Through each iteration the chosen row is popped from the table first, so that each iteration will be smaller from the previous. When the rows are checked against each other, each specified column (or if columns were excluded, all the non-excluded columns) have their values compared between the rows. If at least one of these values are unique between the rows, the two rows are not duplicates. It then stops checking values for the two rows and moves to check the next row. If the predicate fails to find unique values between the rows, it attempts to add the duplicate row to a set of duplicate rows, which is then shown in the report. Potential problems arise when columns are somehow specified wrongly, as the predicate will collect None type values from non-existent columns and check them against each other, which are then seen as duplicates. Another problem is when primary key values are checked as well, as these should never be duplicates, but the rest of the attributes may still be duplicates between two rows, and thus that information is missed, the programmer needs to be aware of this.
