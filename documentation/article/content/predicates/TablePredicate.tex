\subsection{TablePredicate}
TablePredicate is a variation of the RuleColumnPredicate in \cref{RCP}. The difference being that TablePredicate allows the user check their constraint against an the entire column at once, instead of going through each row as RuleColumnPredicate does. The input to arguments of the constraint is by default a list, each representing the column(s) in the order they are specified. However if return\_list is set to false, the input for the constraint is either the sum if the column contains integers, or the join of all the strings if the column contains strings. TablePredicate is instantiated as follows, with description of the parameters below

\insertcodefile{codeRelated/scripts/TablePredicate.py}{Instantiation of TablePredicate}

\begin{description}
\item [table\_name] a string containing the name of specific table from a data warehouse. 
\item [constraint\_function] a function that represent the constraint which needs to be tested. When called it must return either true, if the constraint is fulfilled, or false if it's not.
\item [column\_names] a list of strings or a string containing the name(s) of the column(s), which specifies which column(s) the predicate should test within the table
\item [return\_list] a bool, if false then all elements from the column(s) are sent as arguments to the constraint function as either the sum of the column(s) if they contain integers, or the join of all the strings if the column contains strings. If true they are sent as a list instead. Default is True.
\end{description}

TablePredicate iterates over all the rows in the specified table compiling a list of lists, where each list inserted contains all the elements of one of the specified column(s). Then if return\_list is true, it calls the constraint function with the list as arguments. If return\_list is false, it checks what type each column is. If the elements in a column is integers, then we give the sum of those as an argument to the constraint
