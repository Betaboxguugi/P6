\section{Overview of \FW{}}\label{sect:Overview}
In this section we give an overview of \FW{} and its major components. The sections following this,  goes into detail about each individual part of the framework.

The purpose of \FW{} is to assist in functional source to target testing of ETL programs developed using pygrametl. As such, testing is performed by asserting about properties of DWs, which have been populated by an ETL program. The focus of testing lies on data loss and business rules. Testers can make assertions about new functionality or perform regression testing using old assertions. Testing is performed at the system level, meaning that the extraction, transformation and loading components have been integrated prior to test. The framework is not designed for exhaustive testing, but rather it is meant to assist in reaching an adequate level of test coverage.

\FW{} contains four major components:
\begin{itemize}
\item\textbf{DWPopulator}
\item\textbf{DWRepresentation}
\item\textbf{Predicates}
\item\textbf{Case}
\end{itemize}

The purpose of the DWPopulator is to avoid having users change their pygrametl programs for testing. ETL developers will often hardcode connections to sources and DW's into their ETL program. These contain actual data collected and used by the organization. Because of regulations such data is not available for testers to use. Thus, they have to create their own test sources and DW's. However, they should avoid having to hardcode connections to test data in their programs, as this may be time consuming and error prone. Instead, the reinterpreter allows users to dynamically insert test connections into their ETL program, when performing tests.

The DWPopulator also assists in building a DWRepresentation object from the ETL program under test. DWRepresentation is a class made to contain structural information about the DW being populated. It also allows for easy access of the DW tables and their meta data.

The Predicates are a family of classes used to make assertions about a populated DW. All of them inherit from the Predicate class. Testers make assertions by instantiating a predicate class with the tables of interest along with some other arguments depending on the predicate type. Once instantiated, a predicate can be made to check whether the defined assertion hold or not and then report upon it.

The Case is a class representing a test case, and serves as a users primary way of interacting with \FW{}. It is the class used to run a set of predicates on a DWRepresentation. It is also responsible for reporting the results of the predicates back to the users.

Below is an example of a \FW{} program, some of the modules used are explained further in depth in later sections.

\insertcodefile{Case.py}{Example of a \FW{} program}

In \cref{Case.py} we first execute a pygrametl program, but with other specified sources for extract data, using the DWPopulator. This results in a populated DW from which the DWPopulator creates a DWRepresentation object. We then set up a set of predicates that we wish to test for, in this case it is if there is referential integrety in the DW and if \texttt{table1} has exactly 99 rows. After this we run these predicates on the provided DWRepresentation using the Case class. If the predicates' assertions couldn't hold, the Case object would report this to the user per predicate. Note, that instead of using the DWPopulator to create a DWRepresentation from a pygrametl program, the user could instead have created a DWRepresentation himself that holds information regarding an already populated DW.

In the following sections we go into detail about the implementation of the three of the four components discussed in this section, i.e. DWPopulator, DWRepresentation and the predicates.







