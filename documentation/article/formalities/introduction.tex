\section*{Introduction} % The \section*{} command stops section numbering
\addcontentsline{toc}{section}{Introduction} % Adds this section to the table of contents

To make sure that a piece of software can be expected to run with low risk, it must be tested. Today we have specialized software that assist in the automatic execution of tests. This allows testers to focus more on what to test and less on test implementation. Conceptually this should lead to tests of a higher quality.

Some testing tools such as JUnit have a  broad application, while other test frameworks have a more specific use. In extension, there exists many tools exclusively used for testing  Extract-Transform-Load (ETL) systems. These systems support the creation and update of data warehouses (DW), which are mainly used for business analysis. An ETL process will extract data from a set of sources, apply transformations to that data and then load it into a DW. Often GUI-based tools are used, when developing ETL systems. The pygrametl python package is open source, and it allows for coding ETL systems instead. The idea being that experts perform better when using an API rather than a GUI \cite{thomsen2009pygrametl}. Our goal for this article is to develop a testing framework, which may assist users of pygrametl in testing their ETL systems. 

Looking into the current market of ETL testing toolkits, we find that much testing occurs through the comparison of DWs. The ETL under test generates a DW, which is then compared to another DW. The latter DW may be handwritten or generated by an earlier version of the ETL. Tools like ETLDiff\cite{thomsen2006etldiff} support Diff testing. Here a test passes, if no significant difference between the two DWs can be found. AnyDBTest\cite{AnyDbTest} is a more flexible, letting testers describe when a comparison should pass. An issue with comparison-based testing is that an earlier version of the ETL being tested must exist. Otherwise the tester must manually set up a DW. This has the disadvantage of increasing both the time spent on testing and the probability of errors in the tests. Thus, the comparison approach is mostly used for  regression testing. QuerySurge\cite{QuerySurge} is a testing tool, which does not require the comparison of DWs. Instead it relies on comparing contents of a DW with its source data. The tool is designed with the idea that much of the source data ends up unaltered in the DW. This is easy to check, so often testing does not require programming knowledge. However, QuerySurge does allow for SQL tests to be written, when needed. This tool can be used for regression testing, but also functional testing during the integration and system testing phases of development. So while the previous tools test only for regression in code, QuerySurge allows us to test if functionality meets requirements. Our issue with QuerySurge is that testing occurs through a GUI, and the whole product is geared towards novices and experts alike. Users of pygrametl are generally database experts with a lot of coding experience. Thus they have no need for a lot of novice-friendly features of QuerySurge. Especially the use of a GUI is a contingency point, as users of pygrametl use the package to get away from GUI development. 

Based on this brief look into the state of the art, we deem that no tool is well fit to couple with pygrametl. At least in the case where we want to not only do regression testing, but functional testing in general. Thus, we set out to develop our own testing framework. We want tests to be fast to define and fast to run. This means that we do not want to bother with comparing DWs. Instead we introduce our own concept of test predicates. A test case will take as input; a set of sources, a DW to load data into and a set of predicates. During test the ETL will be run with the given sources and DW. After load, the DW  is placed under the scrutiny of the predicates. A predicate should be seen as a quality that we assert the DW to posses. An example could be a predicate stating that the foreign key constraint is upheld through the entire DW. The test will only pass, if all given predicates are fulfilled by the DW. The whole idea behind predicates is that they can be used to express functional requirements during system testing. They may also be used to express test requirements during integration testing after the extract and load components have been finished. This enables continuous integration of data transformation components. In extension, the predicates can also be used for regression testing. We decide that the testing framework should not be geared towards the earlier component test phase. In this phase individual components are tested, usually during unit tests. We assume the users of pygrametl to be able to test the individual functions of their ETL system, Thus, our aim is to build a framework that instead assist in later phases of testing, which are deemed to be more difficult for users to implement. 

%Terra incognita
%Here be related works.

%Doot doot
%Here be contents
