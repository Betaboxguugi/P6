\section{Introduction} % The \section*{} command stops section numbering
%\addcontentsline{toc}{section}{Introduction} % Adds this section to the table of contents
To make sure that a piece of software can be expected to run with low risk, it must be tested. Today we have specialized software that assist in the automatic execution of tests. This allows testers to focus more on what to test and less on test implementation. Conceptually this should lead to tests of a higher quality.

Some testing tools such as JUnit have a broad application, while other test frameworks have a more specific use. Per extension, there exists many tools exclusively used for testing Extract-Transform-Load (ETL) systems. These systems support the creation and update of data warehouses (DW), which are mainly used for business analysis. An ETL process will extract data from a set of sources, apply transformations to that data and then load it into a DW. Often GUI-based tools are used, when developing ETL systems. The pygrametl python package is open source, and it allows for coding ETL systems instead. The idea being that experts perform better when using an API rather than a GUI \cite{thomsen2009pygrametl}. Our goal for this article is to develop a testing framework, which may assist users of pygrametl in testing their ETL systems.

ETL testing may be done manually. Yet, in the current market many different testing tools exists. These  allow for the automation of tests. Testing often occurs by focusing on the DW, which the ETL system populates. QuerySurge\cite{QuerySurge} is one such testing tool. It focuses on comparing the data from sources to the data in the DW. QuerySurge is build on  the idea that data is often unaltered as it passes through the ETL process. This means that column A in a source may be one-to-one mappable to column B in the DW. Testing of this type only requires the user to supply some simple mappings between sources and DW. As such, QuerySurge presents itself as novice-friendly and allows for testing through a GUI. Yet, if mappings between source data and DW become more complex, testers will need to write up some SQL code. We determine that this kind of tool is not fitting for the users of pygrametl. As pygrametl users are experts, they will not gain anything from the novice-friendly features of the QuerySurge. The amount of code needed for testing may also be rather large, if there is a frequent need for writing SQL. 

Testing may also occur through the comparison of tables within a DW to those defined by the user. By writing up a table, testers assert, how they expect a DW table to look. The truth value of this assertion can be found by comparing to the actual DW table. For this, tools such as AnyDBTest\cite{AnyDbTest} may be used. AnyDBTest also allows testers to describe, what kind of comparison should be made. For example, we may test that one table is the subset of another. Our issue with this type of testing requires the setup of many user-defined tables. Thus a large amount of test code needs to be written. We do however believe that table comparison is a powerful tool for ETL testing. Yet, comparison between tables should not be the only assertable property of a DW.

Having looked at some of the  currently available tools, we find that they require a lot of test code to be written. To get a wider test coverage, we need to decrease the amount of code necessary for each test. We also fear that faults may be more likely to occur in the test code, as it grows larger. Such faults can undermines the usefulness and accuracy of test results. 

In this article we describe \FW{}, a framework that assists in automating  ETL-testing. Like AnyDBTest it is assertion based. However, it does not only allow for assertions to be made upon the relationships of tables. Assertions may relate to other DW properties such as data integrity. Thus,  some properties can be checked without writing up entire tables. The framework allows for functional testing at the system level. As test execution is automated, it is  also useful for regression testing. We aim to help testers in writing less code for each test. This should lead to less time spend on each test and better quality testing overall. We also need for the tests to be executed at a reasonable speed.  

\subsection{Related Works}


\subsection{Overview}
The rest of this paper is organized as followed
\begin{itemize}
	\item{\cref{sect:btesting} where we summarize the basic concepts of software testing}
	\item{\cref{sect:hwtest} in which we look how testing may work in an ETL context}
	\item{\cref{sect:reinterpreter} where we present the reinterpreter part of \FW}
\end{itemize}

