\Abstract{This article describes our development on the testing framework \FW{}, that works in conjunction with the framework pygrametl, an API that allows users to code ETL systems. pyrgrametl handling of ETL system's is rather unique, as they are usually made and tested through GUI's rather than API's. We set out to develop a test framework, \FW{}, which should ease the testing of ETL systems in pygrametl by redcuing the amount of statements need to describe the various test, in contrast to manual testing which in time of writing is the only alternative. We see that the important part of ETL testing is source-to-target tests, and the framework is developed around this concept. This allow users to test the properties of a datawarehouse, which results of their pygrametl program with assorted source databases. Testing these properties is done through predicates, that are a major component of \FW{}. We conclude that \FW{} has significantly more expressive power then the manual tests, which indicate that \FW{} could be more attractive to programmers of ETL systems instead of manual testing solutions.}

%Motivation:
%Why do we care about the problem and the results? If the problem isn't obviously "interesting" it might be better to put motivation first; but if your work is incremental progress on a problem that is widely recognized as important, then it is probably better to put the problem statement first to indicate which piece of the larger problem you are breaking off to work on. This section should include the importance of your work, the difficulty of the area, and the impact it might have if successful.

%Problem statement:
%What problem are you trying to solve? What is the scope of your work (a generalized approach, or for a specific situation)? Be careful not to use too much jargon. In some cases it is appropriate to put the problem statement before the motivation, but usually this only works if most readers already understand why the problem is important.

%Approach:
%How did you go about solving or making progress on the problem? Did you use simulation, analytic models, prototype construction, or analysis of field data for an actual product? What was the extent of your work (did you look at one application program or a hundred programs in twenty different programming languages?) What important variables did you control, ignore, or measure?

%Results:
%What's the answer? Specifically, most good computer architecture papers conclude that something is so many percent faster, cheaper, smaller, or otherwise better than something else. Put the result there, in numbers. Avoid vague, hand-waving results such as "very", "small", or "significant." If you must be vague, you are only given license to do so when you can talk about orders-of-magnitude improvement. There is a tension here in that you should not provide numbers that can be easily misinterpreted, but on the other hand you don't have room for all the caveats.

%Conclusions:
%What are the implications of your answer? Is it going to change the world (unlikely), be a significant "win", be a nice hack, or simply serve as a road sign indicating that this path is a waste of time (all of the previous results are useful). Are your results general, potentially generalizable, or specific to a particular case?